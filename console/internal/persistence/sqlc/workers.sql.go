// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workers.sql

package sqlc

import (
	"context"
)

const clearAllWorkerSessions = `-- name: ClearAllWorkerSessions :execrows
UPDATE worker_nodes
SET session_id = ''
WHERE session_id <> ''
`

func (q *Queries) ClearAllWorkerSessions(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, clearAllWorkerSessions)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const clearWorkerSessionByNode = `-- name: ClearWorkerSessionByNode :execrows
UPDATE worker_nodes
SET session_id = ''
WHERE node_id = ?
`

func (q *Queries) ClearWorkerSessionByNode(ctx context.Context, nodeID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, clearWorkerSessionByNode, nodeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const clearWorkerSessionByNodeAndSession = `-- name: ClearWorkerSessionByNodeAndSession :execrows
UPDATE worker_nodes
SET session_id = ''
WHERE node_id = ? AND session_id = ?
`

type ClearWorkerSessionByNodeAndSessionParams struct {
	NodeID    string `json:"node_id"`
	SessionID string `json:"session_id"`
}

func (q *Queries) ClearWorkerSessionByNodeAndSession(ctx context.Context, arg ClearWorkerSessionByNodeAndSessionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, clearWorkerSessionByNodeAndSession, arg.NodeID, arg.SessionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const countWorkerNodesByOwnerAndType = `-- name: CountWorkerNodesByOwnerAndType :one
SELECT COUNT(1)
FROM worker_nodes wn
JOIN worker_labels owner_label
  ON owner_label.node_id = wn.node_id
  AND owner_label.label_key = 'obx.owner_id'
JOIN worker_labels type_label
  ON type_label.node_id = wn.node_id
  AND type_label.label_key = 'obx.worker_type'
WHERE owner_label.label_value = ?
  AND type_label.label_value = ?
`

type CountWorkerNodesByOwnerAndTypeParams struct {
	LabelValue   string `json:"label_value"`
	LabelValue_2 string `json:"label_value_2"`
}

func (q *Queries) CountWorkerNodesByOwnerAndType(ctx context.Context, arg CountWorkerNodesByOwnerAndTypeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWorkerNodesByOwnerAndType, arg.LabelValue, arg.LabelValue_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOfflineRuntimeWorkers = `-- name: DeleteOfflineRuntimeWorkers :execrows
DELETE FROM worker_nodes
WHERE provisioned = 0
  AND last_seen_at_unix_ms < ?
`

func (q *Queries) DeleteOfflineRuntimeWorkers(ctx context.Context, lastSeenAtUnixMs int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteOfflineRuntimeWorkers, lastSeenAtUnixMs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWorkerCapabilitiesByNode = `-- name: DeleteWorkerCapabilitiesByNode :exec
DELETE FROM worker_capabilities
WHERE node_id = ?
`

func (q *Queries) DeleteWorkerCapabilitiesByNode(ctx context.Context, nodeID string) error {
	_, err := q.db.ExecContext(ctx, deleteWorkerCapabilitiesByNode, nodeID)
	return err
}

const deleteWorkerCredentialByNode = `-- name: DeleteWorkerCredentialByNode :execrows
DELETE FROM worker_credentials
WHERE node_id = ?
`

func (q *Queries) DeleteWorkerCredentialByNode(ctx context.Context, nodeID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWorkerCredentialByNode, nodeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWorkerLabelsByNode = `-- name: DeleteWorkerLabelsByNode :exec
DELETE FROM worker_labels
WHERE node_id = ?
`

func (q *Queries) DeleteWorkerLabelsByNode(ctx context.Context, nodeID string) error {
	_, err := q.db.ExecContext(ctx, deleteWorkerLabelsByNode, nodeID)
	return err
}

const deleteWorkerNodeByID = `-- name: DeleteWorkerNodeByID :execrows
DELETE FROM worker_nodes
WHERE node_id = ?
`

func (q *Queries) DeleteWorkerNodeByID(ctx context.Context, nodeID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWorkerNodeByID, nodeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getWorkerCredentialByNode = `-- name: GetWorkerCredentialByNode :one
SELECT
    node_id,
    secret_hash,
    hash_algo,
    created_at_unix_ms,
    updated_at_unix_ms
FROM worker_credentials
WHERE node_id = ?
LIMIT 1
`

func (q *Queries) GetWorkerCredentialByNode(ctx context.Context, nodeID string) (WorkerCredential, error) {
	row := q.db.QueryRowContext(ctx, getWorkerCredentialByNode, nodeID)
	var i WorkerCredential
	err := row.Scan(
		&i.NodeID,
		&i.SecretHash,
		&i.HashAlgo,
		&i.CreatedAtUnixMs,
		&i.UpdatedAtUnixMs,
	)
	return i, err
}

const getWorkerNodeByID = `-- name: GetWorkerNodeByID :one
SELECT
    node_id,
    session_id,
    provisioned,
    node_name,
    executor_kind,
    version,
    registered_at_unix_ms,
    last_seen_at_unix_ms
FROM worker_nodes
WHERE node_id = ?
LIMIT 1
`

func (q *Queries) GetWorkerNodeByID(ctx context.Context, nodeID string) (WorkerNode, error) {
	row := q.db.QueryRowContext(ctx, getWorkerNodeByID, nodeID)
	var i WorkerNode
	err := row.Scan(
		&i.NodeID,
		&i.SessionID,
		&i.Provisioned,
		&i.NodeName,
		&i.ExecutorKind,
		&i.Version,
		&i.RegisteredAtUnixMs,
		&i.LastSeenAtUnixMs,
	)
	return i, err
}

const insertProvisionedWorkerNodeIfAbsent = `-- name: InsertProvisionedWorkerNodeIfAbsent :execrows
INSERT INTO worker_nodes (
    node_id,
    session_id,
    provisioned,
    node_name,
    executor_kind,
    version,
    registered_at_unix_ms,
    last_seen_at_unix_ms
) VALUES (?, '', 1, ?, '', '', ?, ?)
ON CONFLICT(node_id) DO NOTHING
`

type InsertProvisionedWorkerNodeIfAbsentParams struct {
	NodeID             string `json:"node_id"`
	NodeName           string `json:"node_name"`
	RegisteredAtUnixMs int64  `json:"registered_at_unix_ms"`
	LastSeenAtUnixMs   int64  `json:"last_seen_at_unix_ms"`
}

func (q *Queries) InsertProvisionedWorkerNodeIfAbsent(ctx context.Context, arg InsertProvisionedWorkerNodeIfAbsentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertProvisionedWorkerNodeIfAbsent,
		arg.NodeID,
		arg.NodeName,
		arg.RegisteredAtUnixMs,
		arg.LastSeenAtUnixMs,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertWorkerCapability = `-- name: InsertWorkerCapability :exec
INSERT INTO worker_capabilities (
    node_id,
    capability_name,
    max_inflight
) VALUES (?, ?, ?)
ON CONFLICT(node_id, capability_name) DO UPDATE SET
    max_inflight = excluded.max_inflight
`

type InsertWorkerCapabilityParams struct {
	NodeID         string `json:"node_id"`
	CapabilityName string `json:"capability_name"`
	MaxInflight    int64  `json:"max_inflight"`
}

func (q *Queries) InsertWorkerCapability(ctx context.Context, arg InsertWorkerCapabilityParams) error {
	_, err := q.db.ExecContext(ctx, insertWorkerCapability, arg.NodeID, arg.CapabilityName, arg.MaxInflight)
	return err
}

const insertWorkerCredentialIfAbsent = `-- name: InsertWorkerCredentialIfAbsent :execrows
INSERT INTO worker_credentials (
    node_id,
    secret_hash,
    hash_algo,
    created_at_unix_ms,
    updated_at_unix_ms
) VALUES (?, ?, ?, ?, ?)
ON CONFLICT(node_id) DO NOTHING
`

type InsertWorkerCredentialIfAbsentParams struct {
	NodeID          string `json:"node_id"`
	SecretHash      string `json:"secret_hash"`
	HashAlgo        string `json:"hash_algo"`
	CreatedAtUnixMs int64  `json:"created_at_unix_ms"`
	UpdatedAtUnixMs int64  `json:"updated_at_unix_ms"`
}

func (q *Queries) InsertWorkerCredentialIfAbsent(ctx context.Context, arg InsertWorkerCredentialIfAbsentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWorkerCredentialIfAbsent,
		arg.NodeID,
		arg.SecretHash,
		arg.HashAlgo,
		arg.CreatedAtUnixMs,
		arg.UpdatedAtUnixMs,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertWorkerLabel = `-- name: InsertWorkerLabel :exec
INSERT INTO worker_labels (
    node_id,
    label_key,
    label_value
) VALUES (?, ?, ?)
ON CONFLICT(node_id, label_key) DO UPDATE SET
    label_value = excluded.label_value
`

type InsertWorkerLabelParams struct {
	NodeID     string `json:"node_id"`
	LabelKey   string `json:"label_key"`
	LabelValue string `json:"label_value"`
}

func (q *Queries) InsertWorkerLabel(ctx context.Context, arg InsertWorkerLabelParams) error {
	_, err := q.db.ExecContext(ctx, insertWorkerLabel, arg.NodeID, arg.LabelKey, arg.LabelValue)
	return err
}

const insertWorkerSysOwnerClaimIfAbsent = `-- name: InsertWorkerSysOwnerClaimIfAbsent :execrows
INSERT INTO worker_sys_owner_claims (
    owner_id,
    node_id,
    claimed_at_unix_ms
) VALUES (?, ?, ?)
ON CONFLICT(owner_id) DO NOTHING
`

type InsertWorkerSysOwnerClaimIfAbsentParams struct {
	OwnerID         string `json:"owner_id"`
	NodeID          string `json:"node_id"`
	ClaimedAtUnixMs int64  `json:"claimed_at_unix_ms"`
}

func (q *Queries) InsertWorkerSysOwnerClaimIfAbsent(ctx context.Context, arg InsertWorkerSysOwnerClaimIfAbsentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWorkerSysOwnerClaimIfAbsent, arg.OwnerID, arg.NodeID, arg.ClaimedAtUnixMs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const listOnlineWorkerNodeIDsByCapability = `-- name: ListOnlineWorkerNodeIDsByCapability :many
SELECT wn.node_id
FROM worker_nodes wn
JOIN worker_capabilities wc ON wc.node_id = wn.node_id
WHERE LOWER(wc.capability_name) = ?
  AND wn.last_seen_at_unix_ms >= ?
  AND wn.session_id <> ''
ORDER BY wn.node_id ASC
`

type ListOnlineWorkerNodeIDsByCapabilityParams struct {
	CapabilityName   string `json:"capability_name"`
	LastSeenAtUnixMs int64  `json:"last_seen_at_unix_ms"`
}

func (q *Queries) ListOnlineWorkerNodeIDsByCapability(ctx context.Context, arg ListOnlineWorkerNodeIDsByCapabilityParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listOnlineWorkerNodeIDsByCapability, arg.CapabilityName, arg.LastSeenAtUnixMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var node_id string
		if err := rows.Scan(&node_id); err != nil {
			return nil, err
		}
		items = append(items, node_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOnlineWorkerNodeIDsByOwnerTypeAndCapability = `-- name: ListOnlineWorkerNodeIDsByOwnerTypeAndCapability :many
SELECT wn.node_id
FROM worker_nodes wn
JOIN worker_capabilities wc
  ON wc.node_id = wn.node_id
JOIN worker_labels owner_label
  ON owner_label.node_id = wn.node_id
  AND owner_label.label_key = 'obx.owner_id'
JOIN worker_labels type_label
  ON type_label.node_id = wn.node_id
  AND type_label.label_key = 'obx.worker_type'
WHERE LOWER(wc.capability_name) = ?
  AND owner_label.label_value = ?
  AND type_label.label_value = ?
  AND wn.last_seen_at_unix_ms >= ?
  AND wn.session_id <> ''
ORDER BY wn.node_id ASC
`

type ListOnlineWorkerNodeIDsByOwnerTypeAndCapabilityParams struct {
	CapabilityName   string `json:"capability_name"`
	LabelValue       string `json:"label_value"`
	LabelValue_2     string `json:"label_value_2"`
	LastSeenAtUnixMs int64  `json:"last_seen_at_unix_ms"`
}

func (q *Queries) ListOnlineWorkerNodeIDsByOwnerTypeAndCapability(ctx context.Context, arg ListOnlineWorkerNodeIDsByOwnerTypeAndCapabilityParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listOnlineWorkerNodeIDsByOwnerTypeAndCapability,
		arg.CapabilityName,
		arg.LabelValue,
		arg.LabelValue_2,
		arg.LastSeenAtUnixMs,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var node_id string
		if err := rows.Scan(&node_id); err != nil {
			return nil, err
		}
		items = append(items, node_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerCapabilitiesAll = `-- name: ListWorkerCapabilitiesAll :many
SELECT
    node_id,
    capability_name,
    max_inflight
FROM worker_capabilities
ORDER BY node_id ASC, capability_name ASC
`

func (q *Queries) ListWorkerCapabilitiesAll(ctx context.Context) ([]WorkerCapability, error) {
	rows, err := q.db.QueryContext(ctx, listWorkerCapabilitiesAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkerCapability
	for rows.Next() {
		var i WorkerCapability
		if err := rows.Scan(&i.NodeID, &i.CapabilityName, &i.MaxInflight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerCapabilitiesByNode = `-- name: ListWorkerCapabilitiesByNode :many
SELECT
    capability_name,
    max_inflight
FROM worker_capabilities
WHERE node_id = ?
ORDER BY capability_name ASC
`

type ListWorkerCapabilitiesByNodeRow struct {
	CapabilityName string `json:"capability_name"`
	MaxInflight    int64  `json:"max_inflight"`
}

func (q *Queries) ListWorkerCapabilitiesByNode(ctx context.Context, nodeID string) ([]ListWorkerCapabilitiesByNodeRow, error) {
	rows, err := q.db.QueryContext(ctx, listWorkerCapabilitiesByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkerCapabilitiesByNodeRow
	for rows.Next() {
		var i ListWorkerCapabilitiesByNodeRow
		if err := rows.Scan(&i.CapabilityName, &i.MaxInflight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerCredentials = `-- name: ListWorkerCredentials :many
SELECT
    node_id,
    secret_hash,
    hash_algo,
    created_at_unix_ms,
    updated_at_unix_ms
FROM worker_credentials
ORDER BY node_id ASC
`

func (q *Queries) ListWorkerCredentials(ctx context.Context) ([]WorkerCredential, error) {
	rows, err := q.db.QueryContext(ctx, listWorkerCredentials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkerCredential
	for rows.Next() {
		var i WorkerCredential
		if err := rows.Scan(
			&i.NodeID,
			&i.SecretHash,
			&i.HashAlgo,
			&i.CreatedAtUnixMs,
			&i.UpdatedAtUnixMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerLabelsAll = `-- name: ListWorkerLabelsAll :many
SELECT
    node_id,
    label_key,
    label_value
FROM worker_labels
ORDER BY node_id ASC, label_key ASC
`

func (q *Queries) ListWorkerLabelsAll(ctx context.Context) ([]WorkerLabel, error) {
	rows, err := q.db.QueryContext(ctx, listWorkerLabelsAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkerLabel
	for rows.Next() {
		var i WorkerLabel
		if err := rows.Scan(&i.NodeID, &i.LabelKey, &i.LabelValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerLabelsByNode = `-- name: ListWorkerLabelsByNode :many
SELECT
    label_key,
    label_value
FROM worker_labels
WHERE node_id = ?
ORDER BY label_key ASC
`

type ListWorkerLabelsByNodeRow struct {
	LabelKey   string `json:"label_key"`
	LabelValue string `json:"label_value"`
}

func (q *Queries) ListWorkerLabelsByNode(ctx context.Context, nodeID string) ([]ListWorkerLabelsByNodeRow, error) {
	rows, err := q.db.QueryContext(ctx, listWorkerLabelsByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkerLabelsByNodeRow
	for rows.Next() {
		var i ListWorkerLabelsByNodeRow
		if err := rows.Scan(&i.LabelKey, &i.LabelValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerNodeIDsByOwnerAndType = `-- name: ListWorkerNodeIDsByOwnerAndType :many
SELECT wn.node_id
FROM worker_nodes wn
JOIN worker_labels owner_label
  ON owner_label.node_id = wn.node_id
  AND owner_label.label_key = 'obx.owner_id'
JOIN worker_labels type_label
  ON type_label.node_id = wn.node_id
  AND type_label.label_key = 'obx.worker_type'
WHERE owner_label.label_value = ?
  AND type_label.label_value = ?
ORDER BY wn.node_id ASC
`

type ListWorkerNodeIDsByOwnerAndTypeParams struct {
	LabelValue   string `json:"label_value"`
	LabelValue_2 string `json:"label_value_2"`
}

func (q *Queries) ListWorkerNodeIDsByOwnerAndType(ctx context.Context, arg ListWorkerNodeIDsByOwnerAndTypeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listWorkerNodeIDsByOwnerAndType, arg.LabelValue, arg.LabelValue_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var node_id string
		if err := rows.Scan(&node_id); err != nil {
			return nil, err
		}
		items = append(items, node_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkerNodesOrdered = `-- name: ListWorkerNodesOrdered :many
SELECT
    node_id,
    session_id,
    provisioned,
    node_name,
    executor_kind,
    version,
    registered_at_unix_ms,
    last_seen_at_unix_ms
FROM worker_nodes
ORDER BY registered_at_unix_ms ASC, node_id ASC
`

func (q *Queries) ListWorkerNodesOrdered(ctx context.Context) ([]WorkerNode, error) {
	rows, err := q.db.QueryContext(ctx, listWorkerNodesOrdered)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkerNode
	for rows.Next() {
		var i WorkerNode
		if err := rows.Scan(
			&i.NodeID,
			&i.SessionID,
			&i.Provisioned,
			&i.NodeName,
			&i.ExecutorKind,
			&i.Version,
			&i.RegisteredAtUnixMs,
			&i.LastSeenAtUnixMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkerHeartbeatBySession = `-- name: UpdateWorkerHeartbeatBySession :execrows
UPDATE worker_nodes
SET last_seen_at_unix_ms = ?
WHERE node_id = ? AND session_id = ?
`

type UpdateWorkerHeartbeatBySessionParams struct {
	LastSeenAtUnixMs int64  `json:"last_seen_at_unix_ms"`
	NodeID           string `json:"node_id"`
	SessionID        string `json:"session_id"`
}

func (q *Queries) UpdateWorkerHeartbeatBySession(ctx context.Context, arg UpdateWorkerHeartbeatBySessionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateWorkerHeartbeatBySession, arg.LastSeenAtUnixMs, arg.NodeID, arg.SessionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertWorkerNode = `-- name: UpsertWorkerNode :exec
INSERT INTO worker_nodes (
    node_id,
    session_id,
    provisioned,
    node_name,
    executor_kind,
    version,
    registered_at_unix_ms,
    last_seen_at_unix_ms
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(node_id) DO UPDATE SET
    session_id = excluded.session_id,
    provisioned = excluded.provisioned,
    node_name = excluded.node_name,
    executor_kind = excluded.executor_kind,
    version = excluded.version,
    registered_at_unix_ms = excluded.registered_at_unix_ms,
    last_seen_at_unix_ms = excluded.last_seen_at_unix_ms
`

type UpsertWorkerNodeParams struct {
	NodeID             string `json:"node_id"`
	SessionID          string `json:"session_id"`
	Provisioned        int64  `json:"provisioned"`
	NodeName           string `json:"node_name"`
	ExecutorKind       string `json:"executor_kind"`
	Version            string `json:"version"`
	RegisteredAtUnixMs int64  `json:"registered_at_unix_ms"`
	LastSeenAtUnixMs   int64  `json:"last_seen_at_unix_ms"`
}

func (q *Queries) UpsertWorkerNode(ctx context.Context, arg UpsertWorkerNodeParams) error {
	_, err := q.db.ExecContext(ctx, upsertWorkerNode,
		arg.NodeID,
		arg.SessionID,
		arg.Provisioned,
		arg.NodeName,
		arg.ExecutorKind,
		arg.Version,
		arg.RegisteredAtUnixMs,
		arg.LastSeenAtUnixMs,
	)
	return err
}
